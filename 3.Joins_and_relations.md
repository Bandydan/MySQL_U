# 3. Joins, відносини, практика запитів

## Відносини між таблицями

Як ми вже обговорювали, mySQL відноситься до реляційних баз даних. Реляційні БД характеризуються наявністю таблиць та відносин.

Існує 3 типи відносин:

- "**Один до одного**" - коли один запис у першій таблиці відповідає одному запису у другій таблиці. Зустрічається такий зв'язок досить рідко. Така зв'язок чи надмірна, тобто. може сенс просто об'єднати дані в одну таблицю, або це результат модернізації архітектури, і таке рішення кимось прийнято обґрунтовано.

![](https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%BE%D0%B4%D0%B8%D0%BD-%D0%BA%D0%BE-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D1%83.png)

- "**Один до багатьох**" - коли одному запису в першій таблиці відповідає кілька записів в іншій таблиці. Наприклад, клієнт магазину може мати кілька номерів. Один клієнт – один запис у таблиці клієнта, його номери телефонів – записи у таблиці телефонів. Один клієнт відноситься до багатьох номерів телефонів, але зворотний зв'язок - номер телефону до клієнта - багато хто до одного.

![](https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%9E%D0%B4%D0%B8%D0%BD-%D0%BA%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%B8%D0%BC.png)

- "**Багато до багатьох**" - коли одному запису в першій таблиці відповідає кілька записів у другій таблиці, але одному запису другої таблиці може відповідати кілька записів першої таблиці. Класичний приклад - книги та автори, адже автор може мати багато книг, і кожна книга може мати кілька авторів.
Реалізується з допомогою створення таблиці зв'язків, куди копіюються ключі записів обох таблиць.

![](https://zametkinapolyah.ru/wp-content/uploads/2016/05/%D0%9C%D0%BD%D0%BE%D0%B3%D0%B8%D0%B5-%D0%BA%D0%BE-%D0%BC%D0%BD%D0%BE%D0%B3%D0%B8%D0%BC.png)

## Об'єднання (Joins)

Запити до таблиці досить рідкісні. Найчастіше запити до баз даних пишуться з метою отримати інформацію з кількох таблиць, інформація з яких поєднується за певними умовами.

Створимо таблиці авторів, книг, жанрів та таблицю зв'язків для авторів та книг (багато хто до багатьох):

```sql
CREATE TABLE authors (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	name VARCHAR(100) NOT NULL DEFAULT 'people',
	year DATE NOT NULL DEFAULT '1970-01-01'
);

CREATE TABLE books (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	title VARCHAR(100) NOT NULL DEFAULT 'noname',
	genre_id INT NOT NULL DEFAULT '0'
);

CREATE TABLE genres (
	id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	genre VARCHAR(100) NOT NULL DEFAULT 'unknown'
);

CREATE TABLE authors_books (
	author_id INT NOT NULL DEFAULT 0,
	book_id INT NOT NULL DEFAULT 0
);
```

Далі слід заповнити таблицю даними:

```sql
INSERT INTO genres (genre) VALUES
	('SF'),
	('novel'),
	('story'),
	('horror');

INSERT INTO books(title, genre_id) VALUES
	("Майстер й Маргарита", 2),
	("Фауст", 0),
	("Біле ікло", 3),
	("Дюна", 1),
	("Війна та мир", 2);

INSERT INTO authors (name) VALUES
	('Френк Герберт'),
	('Михайло Булгаков'), 
	('Ждек Лондон'), 
	('Йоган Ґёте'), 
	('Роберт Хайнлайн');

INSERT INTO authors_books (author_id, book_id) VALUES 
	(1, 4),
	(2, 1),
	(3, 3),
	(4, 2);
```


![](http://homes.ieu.edu.tr/culudagli/files/CE223/MySQL/mysql-jointypes-1.png)




Дані готові, тепер можна вивчати об'єднання таблиць. Почнемо ми з об'єднання двох таблиць в одному запиті:

```sql
SELECT
	title,
	genre 
FROM 
	books
	INNER JOIN genres ON (books.genre_id = genres.id);
```

```
+------------------------------------+-------+
| title                              | genre |
+------------------------------------+-------+
| Майстер й Маргарита                | novel |
| Біле ікло                          | story |
| Дюна                               | SF    |
| Війна та мир                       | novel |
+------------------------------------+-------+
```

**`INNER JOIN`** виводить записи з лівої таблиці (першої з двох таблиць, які він об'єднує), для яких знайдеться відповідний запис у правій (другій та останній у списку) таблиці. Якщо відповідності у правій таблиці немає, такий запис не виводиться. В даному випадку можна бачити, що запис про книгу "Фауст" не виводиться. Це відбувається через те, що `genre_id` цей запис дорівнює нулю, а такого жанру в таблиці жанрів немає.
Так само в результат не потрапляє жанр horror, тому що немає жодної книги з таким жанром.

```sql
SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres ON (books.genre_id = genres.id);
```
```
+------------------------------------+-------+
| title                              | genre |
+------------------------------------+-------+
| Майстер й Маргарита                | novel |
| Фауст                              | NULL  |
| Біле ікло                          | story |
| Дюна                               | SF    |
| War and Peace                      | novel |
+------------------------------------+-------+
```
**`LEFT JOIN`** виводить **ВСІ** записи з лівої таблиці. Для тих записів, яким знаходиться відповідність у правій, він, аналогічно **INNER JOIN**, виведе відповідні дані з другої таблиці. Для тих, яким відповідності не знайшлося, він виведе в стовпцях правої таблиці **`NULL`**.

**`RIGHT JOIN`** надходить аналогічним чином з правою таблицею: виводить усі записи з неї, додаючи записи з лівої. Де відповідності немає, додає у стовпцях лівої таблиці **`NULL`**.

```sql
SELECT
	title,
	genre 
FROM 
	books
	RIGHT JOIN genres ON (books.genre_id = genres.id);
```

```
+------------------------------------+--------+
| title                              | genre  |
+------------------------------------+--------+
| Майстер й Маргарита                | novel  |
| Біле ікло                          | story  |
| Дюна                               | SF     |
| War and Peace                      | novel  |
| NULL                               | horror |
+------------------------------------+--------+
```


Якщо у вас виникне потреба побачити всі книги та всі жанри незалежно від наявності відповідних записів в іншій таблиці, але де зв'язки є – зв'язати таблиці, можна об'єднати результати двох запитів:


```sql
SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres ON (books.genre_id = genres.id)

UNION

SELECT
	title,
	genre 
FROM 
	books
	RIGHT JOIN genres ON (books.genre_id = genres.id);
```


```
+------------------------------------+--------+
| title                              | genre  |
+------------------------------------+--------+
| Майстер й Маргарита                | novel  |
| Фауст                              | NULL   |
| Біле ікло                          | story  |
| Дюна                               | SF     |
| War and Peace                      | novel  |
| NULL                               | horror |
+------------------------------------+--------+
```

Класичне питання, як подивитися книги, які не мають жанру, вирішується просто:

```sql
SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres ON (books.genre_id = genres.id)
WHERE
	genre IS NULL;
```
```
+------------+-------+
| title      | genre |
+------------+-------+
| Фауст      | NULL  |
+------------+-------+
```
Якщо поля зв'язку називаються однаково, наприклад, поле id у таблиці genres називається genre_id, запит можна трохи спростити. Для демонстрації перейменуємо поле та виконаємо цей запит:

```sql

ALTER TABLE 
	genres 
CHANGE 
	id genre_id INT NOT NULL;

SELECT
	title,
	genre 
FROM 
	books
	LEFT JOIN genres USING(genre_id);
```

Результат буде той самий, що й у звичайного **`LEFT JOIN`** запиту, але сам запит коротший.

## Практика

- Об'єднати авторів із книгами за допомогою таблиці зв'язків
- Побудувати фамільне дерево по чоловічій лінії

## Корисні посилання


[Стаття про joins](https://anton-pribora.ru/articles/mysql/mysql-join/)

[Домашка](homework3.md)

[Наступний урок, Індекси, нормалізація](4.Indexes_and_normalizations.md)

