# MySQL, Маніпуляції з даними

Коли база даних створена та таблиці в ній створені, коли все це зроблено правильним користувачем з правильними правами та рівнем доступу, саме час заповнити таблиці даними. У роботі з даними є лише 4 дії: створення, отримання, зміна та видалення даних. Для позначення цих процесів використовується абревіатура **CRUD: Create, Read, Update, Delete**.

Для експериментів із даними нам знадобиться таблиця. Наприклад, таблиця слів зі словника:

```sql
mysql> DESC words;

+--------+--------------+------+-----+---------+----------------+
| Field  | Type         | Null | Key | Default | Extra          |
+--------+--------------+------+-----+---------+----------------+
| id     | int(11)      | NO   | PRI | NULL    | auto_increment |
| word   | varchar(100) | NO   |     |         |                |
| voc_id | int(11)      | NO   |     | 0       |                |
+--------+--------------+------+-----+---------+----------------+
3 rows in set (0.26 sec)
```

Про всяк випадок наведу команду створення цієї таблиці:

```sql
CREATE TABLE `words` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `word` varchar(100) NOT NULL DEFAULT '',
  `voc_id` int(11) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
);
```

Не слід забувати, що для перегляду структури таблиці ми користуємося запитами **`show create table word;`** та **`desc word;`**

## CRUD даних - Create, додавання даних (INSERT)

Для додавання даних до таблиці використовується оператор **INSERT INTO**. Оператор **`INSERT INTO`** буває декількох видів, і ми розглянемо основні:

### Simple insert

Найпростіший варіант вставки даних у таблицю виглядає так:

```sql
INSERT INTO words SET word = "Earth", voc_id = 1;
```

У цьому прикладі ми вставляємо запис у таблицю word, вказуючи конкретне значення кожного стовпця як пари ключ-значение (key-value pair). Ключем виступає назва поля, значенням – власне інформація, яку ми хочемо помістити в записі до цього поля.
Цей вид вставки даних використовується для додавання одного запису.

### Multiple insert

```sql
INSERT INTO words (word, voc_id) VALUES ("cat", 2), ("dog", 2), ("donkey", 2);
```
Код выше вставляет данные в последующих скобках в соответствующие столбцы, указанные в первых скобках. Таким образом, вначале необходимо перечислить столбцы (поля), в которые планируется вносить данные, а затем через запятую перечислить обернутые скобочками наборы данных для этих полей. Такой запрос позволяет добавлять несколько записей разом.

```sql
INSERT INTO words VALUES (30, "cat", 2), (31, "dog", 2), (32, "donkey", 2);

```
Даний варіант запиту **`INSERT INTO`** використовується, якщо ви плануєте заповнювати всі стовпці, а не лише вибрані.

### Insert from select

Можлива також вставка даних із результату запиту:

```sql
INSERT INTO words (word) SELECT word FROM words;
```
Здесь приведен довольно простой пример, но, по сути дела, если вы построите запрос данных **`SELECT`** таким образом, чтобы количество столбцов в результате соответствовало необходимому, указанному во внешнем запросе **`INSERT`**, вы можете встроить запрос довольно серьезного уровня сложности.

## CRUD данных - Read, выборка данных (SELECT)

Запрос **`SELECT`** используется для получения данных, и никоим образом их не изменяет. Структура его довольно сложна, и мы попробуем разобрать ее постепенно и поэтапно.

Минимальный возможный запрос выглядит так:

```sql
mysql> SELECT 1;
+---+
| 1 |
+---+
| 1 |
+---+
```
Єдиним обов'язковим ключовим словом у запиті **`select`** є слово `select` - вибрати.

Після цього слова слід писати:

- функції mysql ([приклади функцій](https://www.w3schools.com/sql/sql_ref_mysql.asp))
- рядки та числа
- поля таблиць, тимчасових таблиць та уявлень, які ми збираємося вибирати
- похідні від цих полів

Найчастіше **`SELECT`** використовується для роботи з даними з таблиць, і для цього потрібно вказати ці таблиці. Таблиці, якими здійснюється вибірка, перераховуються після ключового слова **`FROM`**:

```sql
SELECT * FROM books;
```

Наведений вище запит вибирає всі поля (за це відповідає зірочка) із таблиці books.

Максимально докладна схема запиту `select` виглядає так:

```sql
SELECT
    <field1>,
    <field2>,
    <field3>
    ...
FROM
    <table1>,
    <table2>,
    <joins>,
    <views>,
    <temp_table>
    ...
WHERE
    <cond>
    
ORDER BY
    <field1> ASC
    <field3> DESC
GROUP BY
    <field 1>
HAVING
    <cond with aggr function>
LIMIT
    N,M
```


Нижче наведено текстовий опис основних елементів структури запиту **`SELECT`**, докладніший опис з прикладами буде наведено пізніше.

1. Після ключового слова **`SELECT`** йде перелік полів таблиць, функцій, що обчислюються з цих полів, констант, незалежних від записів функцій. Для вказівки всіх полів використовується зірочка. Цей пункт є єдиним обов'язковим пунктом у запиті **`SELECT`**, інші опціональні.
2. Далі, після ключового слова **`FROM`** слідує перелік таблиць, уявлень та тимчасових таблиць, звідки ведеться вибірка. Таблиці можуть бути перераховані, а можуть бути приєднані до інших таблиць за описаними окремо правил, тобто. за допомогою **`JOIN`**.
3. Далі слідує умова **`WHERE`**, що пропускає лише ті записи, які задовольняють перерахованим у **`WHERE`** умовам. Всі записи, що не пройшли перевірку, відфільтровуються і не демонструються.
4. Після фільтру **`WHERE`** може слідувати групування записів.
5. Угруповання виконується за допомогою ключових слів **`GROUP BY`**. Суть угруповання в тому, що записи можуть об'єднуватися за ознакою або декількома ознаками в один запис, який несе у собі якусь загальну для всіх записів групи інформацію або результат обробки інформації по всій групі. Конструкція **`GROUP BY`** може включати ключове слово **`HAVING`**, що дозволяє фільтрувати результати угруповання.
6. Важливо відзначити, що угруповання дозволяє використовувати аггрегатні функції як у **`HAVING`**, так і після **`SELECT`**.
5. Після групування може відбутися сортування записів за допомогою ключових слів **ORDER BY**. При групуванні вказується поле або перелік полів, за яким необхідно відсортувати, також можна вказати напрямок сортування. За умовчанням здійснюється сортування за зростанням. Сортування за спаданням здійснюється за допомогою ключового слова **`descending`** або **`desc`**.
6. Наприкінці запиту можливе додавання обмежень на кількість записів. Слово **`LIMIT`** та цифрою після вказує, скільки записів ви хочете бачити в результаті. Якщо після слова **`LIMIT`** додати дві цифри через кому, ви побачите друге число - кількість записів після пропущеного першого числа-кількості записів, тобто. **`LIMIT 20, 5`** пропустить 20 записів та покаже вам 5 наступних.


## Практика з SELECT та INSERT

### DISTINCT

```sql

mysql> select word, voc_id from words;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| dog    |      2 |
| donkey |      2 |
| cat    |      2 |
| dog    |      2 |
| donkey |      2 |
| cat    |      0 |
| dog    |      0 |
| donkey |      0 |
| cat    |      0 |
| dog    |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)


mysql> select distinct word, voc_id from words;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| dog    |      2 |
| donkey |      2 |
| cat    |      0 |
| dog    |      0 |
| donkey |      0 |
+--------+--------+
6 rows in set (0.00 sec)

```


Умова **`distinct`** відкидає кийки в результаті запиту, залишаючи тільки унікальні записи.

### WHERE

Тепер виберемо всі слова і кілька разів відфільтруємо їх за допомогою **`where`**:

```sql

mysql> select * from words;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
|  1 | cat    |      2 |
|  2 | dog    |      2 |
|  3 | donkey |      2 |
| 30 | cat    |      2 |
| 31 | dog    |      2 |
| 32 | donkey |      2 |
| 33 | cat    |      0 |
| 34 | dog    |      0 |
| 35 | donkey |      0 |
| 36 | cat    |      0 |
| 37 | dog    |      0 |
| 38 | donkey |      0 |
+----+--------+--------+
12 rows in set (0.00 sec)


mysql> select * from words where id > 5;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
| 30 | cat    |      2 |
| 31 | dog    |      2 |
| 32 | donkey |      2 |
| 33 | cat    |      0 |
| 34 | dog    |      0 |
| 35 | donkey |      0 |
| 36 | cat    |      0 |
| 37 | dog    |      0 |
| 38 | donkey |      0 |
+----+--------+--------+
9 rows in set (0.00 sec)

mysql> select * from words where id < 5;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
|  1 | cat    |      2 |
|  2 | dog    |      2 |
|  3 | donkey |      2 |
+----+--------+--------+
3 rows in set (0.00 sec)

```

Трохи більше фільтрації та перерахування полів:

```sql

mysql> select * from words where id between 30 and 34;

+----+--------+--------+
| id | word   | voc_id |
+----+--------+--------+
| 30 | cat    |      2 |
| 31 | dog    |      2 |
| 32 | donkey |      2 |
| 33 | cat    |      0 |
| 34 | dog    |      0 |
+----+--------+--------+
5 rows in set (0.01 sec)

```

### GROUP BY

Групувати можна дані, які повторюються у групах і не суперечитимуть умовам угруповання. При групуванні можна логічно використовувати аггрегатні функції. Агрегатні функції - особливі функції SQL, які застосовуються до всіх записів в результаті вибірки, або до груп. Count – одна з таких функцій.


```sql

mysql> select voc_id from words group by voc_id;
+--------+
| voc_id |
+--------+
|      2 |
|      0 |
+--------+
2 rows in set (0.00 sec)

mysql> select voc_id, count(*) from words group by voc_id;

+--------+----------+
| voc_id | count(*) |
+--------+----------+
|      2 |        6 |
|      0 |        6 |
+--------+----------+
2 rows in set (0.00 sec)

```

### GROUP BY HAVING

Ключове слово HAVING додається лише після GROUP BY для додаткової фільтрації результатів запиту. WHERE фільтрує їх до угруповання, HAVING фільтрує згруповані.

```sql

insert into words set word = 'test', voc_id = 2;
Query OK, 1 row affected (0.00 sec)

mysql> select voc_id, count(*) from words group by voc_id having count(*) > 6;
+--------+----------+
| voc_id | count(*) |
+--------+----------+
|      2 |        7 |
+--------+----------+

```

Використовується аггрегатна функція **`count().`**

### ORDER BY

```sql

mysql> select word, voc_id from words order by word;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| cat    |      2 |
| cat    |      0 |
| cat    |      0 |
| dog    |      2 |
| dog    |      2 |
| dog    |      0 |
| dog    |      0 |
| donkey |      2 |
| donkey |      2 |
| donkey |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)

mysql> select word, voc_id from words order by word, voc_id;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      0 |
| cat    |      0 |
| cat    |      2 |
| cat    |      2 |
| dog    |      0 |
| dog    |      0 |
| dog    |      2 |
| dog    |      2 |
| donkey |      0 |
| donkey |      0 |
| donkey |      2 |
| donkey |      2 |
+--------+--------+
12 rows in set (0.00 sec)

mysql> select word, voc_id from words order by word, voc_id desc;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| cat    |      2 |
| cat    |      0 |
| cat    |      0 |
| dog    |      2 |
| dog    |      2 |
| dog    |      0 |
| dog    |      0 |
| donkey |      2 |
| donkey |      2 |
| donkey |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)

mysql> select word, voc_id from words order by 1, 2 desc;

+--------+--------+
| word   | voc_id |
+--------+--------+
| cat    |      2 |
| cat    |      2 |
| cat    |      0 |
| cat    |      0 |
| dog    |      2 |
| dog    |      2 |
| dog    |      0 |
| dog    |      0 |
| donkey |      2 |
| donkey |      2 |
| donkey |      0 |
| donkey |      0 |
+--------+--------+
12 rows in set (0.00 sec)

```

### LIMIT и OFFSET

```sql

mysql> select word, voc_id from words order by 1, 2 desc limit 5;

+------+--------+
| word | voc_id |
+------+--------+
| cat  |      2 |
| cat  |      2 |
| cat  |      0 |
| cat  |      0 |
| dog  |      2 |
+------+--------+
5 rows in set (0.00 sec)

mysql> select word, voc_id from words order by 1, 2 desc limit 5, 2;

+------+--------+
| word | voc_id |
+------+--------+
| dog  |      2 |
| dog  |      0 |
+------+--------+
2 rows in set (0.00 sec)

```
## Корисні посилання


[Типи даних](https://metanit.com/sql/mysql/2.3.php)

[Агрегатні функції](https://metanit.com/sql/mysql/4.5.php)

[Домашка](homework2.md)

[Наступний урок, Об'єднання та відносини](3.Joins_and_relations.md)
